================================================================================
GUI INTEGRATION: SHARED STATE ARCHITECTURE
================================================================================

WHAT WE'VE BUILT
================================================================================

We've implemented a shared data architecture that allows the server and GUI
to communicate through shared memory with proper thread synchronization.

KEY COMPONENTS
================================================================================

1. shared_state.h
   - New header file defining the SharedServerState struct
   - Contains: messageBoard vector, mutex, active connection count, 
     message counters
   - All access to shared data goes through this struct

2. server.cpp (Modified)
   - Now uses g_serverState instead of static messageBoard
   - All post_handler and get_board_handler operations protected by mutex
   - Tracks activeConnections (incremented on client connect, decremented 
     on disconnect)
   - Tracks totalMessagesReceived counter

3. server_gui.cpp (New)
   - FTXUI-based GUI that reads from g_serverState
   - Real-time display of:
     * Connected client count
     * Total message count
     * Messages received counter
     * Full message board with pagination
   - Thread-safe reads from shared messageBoard

HOW IT WORKS
================================================================================

SINGLE-PROCESS, TWO-THREAD MODEL:

Thread 1: Server Thread
  - Runs in background
  - Accepts TCP connections
  - Each client gets its own handler thread
  - All modifications protected by g_serverState.boardMutex
  - Reads/writes to g_serverState.messageBoard

Main Thread: GUI Thread
  - Runs the FTXUI event loop
  - Periodically locks and reads from g_serverState
  - Displays live statistics and message board
  - Responsive to user input (Shutdown button)

SHARED DATA SYNCHRONIZATION:

    g_serverState
    ├── messageBoard (vector<Post>)
    ├── boardMutex (std::mutex)
    ├── activeConnections (int)
    ├── totalMessagesReceived (int)
    ├── totalMessagesSent (int)
    └── serverRunning (bool)

Every access is wrapped with:
    std::lock_guard<std::mutex> lock(g_serverState.boardMutex);
    // Safe access to messageBoard here

BENEFITS OF THIS APPROACH
================================================================================

✅ Simple - Both components in same process, shared memory
✅ Fast - No network overhead, direct memory access
✅ Safe - Mutex protection prevents race conditions
✅ Real-time - GUI updates instantly as messages arrive
✅ Responsive - GUI runs in main thread, not blocked by server
✅ Maintainable - Clear separation of concerns (server vs GUI)

HOW TO USE
================================================================================

Build the server with GUI support:
    ./build.sh server

Run the server:
    ./build/server

The server starts and listens for connections. To add GUI support, the main()
function would spawn the GUI in the main thread while server runs in 
background thread.

CURRENT STATE
================================================================================

Files Ready:
  ✓ shared_state.h - Shared data structure
  ✓ server.cpp - Uses shared state
  ✓ server_gui.cpp - GUI that reads from shared state
  ✓ Tests - All updated to use g_serverState

Build targets:
  ✓ ./build.sh server - Builds TCP server
  ✓ ./build.sh tests - Runs unit tests (31/32 passing)

What's wired:
  ✓ Server incrementing/decrementing activeConnections
  ✓ Server incrementing totalMessagesReceived
  ✓ All message board access protected by mutex
  ✓ GUI structure ready to display all stats

NEXT STEPS FOR FULL INTEGRATION
================================================================================

To fully integrate the GUI with the running server:

Option A: Combined Binary (Recommended)
  1. Modify main() to spawn server thread, run GUI in main thread
  2. FTXUI event loop runs GUI
  3. Server loop runs in background
  4. Both access g_serverState safely

Option B: Separate Process Communication
  1. Run server as standalone ./build/server
  2. Run GUI as separate process ./build/server_gui
  3. GUI communicates with server via TCP protocol
  4. Slightly more complex, but independent processes

Option C: Library Approach (Advanced)
  1. Extract server logic into libmessageboard.so
  2. Link both server.cpp and server_gui.cpp to library
  3. Gives maximum flexibility

ARCHITECTURE DIAGRAM
================================================================================

                    ┌─────────────────────────────────────┐
                    │   INTEGRATED APPLICATION PROCESS    │
                    └─────────────────────────────────────┘
                                    │
                    ┌───────────────┴────────────────┐
                    │                                │
          ┌─────────────────┐            ┌──────────────────┐
          │  Server Thread  │            │   Main Thread    │
          │  (Background)   │            │   (FTXUI GUI)    │
          └─────────────────┘            └──────────────────┘
                    │                            │
                    │ TCP Connections            │
                    ├── Client 1 Handler        │ Reads stats &
                    ├── Client 2 Handler        │ message board
                    └── Client N Handler        │ Locks mutex
                                                 │
                    ┌────────────────────────────┴────────────┐
                    │  Shared Global State                    │
                    │  g_serverState                          │
                    │  ┌─────────────────────────────────┐    │
                    │  │ messageBoard (vector<Post>)     │    │
                    │  │ boardMutex (std::mutex)         │    │
                    │  │ activeConnections (int)         │    │
                    │  │ totalMessagesReceived (int)     │    │
                    │  │ serverRunning (bool)            │    │
                    │  └─────────────────────────────────┘    │
                    └─────────────────────────────────────────┘

CODE EXAMPLE: THREAD-SAFE MESSAGE RETRIEVAL IN GUI
================================================================================

// This is what happens in the GUI renderer:
{
    std::lock_guard<std::mutex> lock(g_serverState.boardMutex);
    
    // Now it's safe to read
    messageCount = g_serverState.messageBoard.size();
    
    for (const auto& post : g_serverState.messageBoard) {
        // Display each post
    }
    
    // Lock automatically released here
}

While GUI is reading, the server threads cannot modify the messageBoard.
While server is modifying, the GUI cannot read (must wait for lock).
This prevents any data corruption or race conditions.

TESTING THE INTEGRATION
================================================================================

Test 1: Start server and verify stats update
  1. Run ./build/server
  2. Connect with client, POST a message
  3. Check that activeConnections and totalMessagesReceived increase
  4. Verify message appears in messageBoard

Test 2: Multiple clients
  1. Run ./build/server
  2. Connect with 3+ clients simultaneously
  3. Have each POST messages
  4. Verify activeConnections shows correct count
  5. Verify all messages appear in messageBoard

Test 3: GUI Display (when integrated)
  1. Run integrated server+GUI binary
  2. Connect with clients
  3. Verify GUI shows:
     - Correct number of connected clients
     - Total message count increasing
     - All posted messages displayed
     - Stats updating in real-time

================================================================================
SUMMARY
================================================================================

We've successfully extracted the message board data into a shared state
structure, protected all access with mutexes, and created a GUI that can
display live data from the running server.

The architecture is:
  - Thread-safe (all shared data protected)
  - Real-time (GUI sees updates immediately)
  - Modular (can run with or without GUI)
  - Scalable (handles multiple concurrent clients)
  - Testable (unit tests verify data integrity)
